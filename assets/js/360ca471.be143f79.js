"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7399],{1951:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(5893),r=t(1151);const a={id:"plugin_intro",description:"Plugin introduction",slug:"/plugin/plugin_intro"},o="Plugin Introduction",s={id:"customization/plugin/plugin_intro",title:"Plugin Introduction",description:"Plugin introduction",source:"@site/docs/customization/plugin/plugin_intro.md",sourceDirName:"customization/plugin",slug:"/plugin/plugin_intro",permalink:"/TaskWeaver/docs/plugin/plugin_intro",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/TaskWeaver/tree/docs/website/docs/customization/plugin/plugin_intro.md",tags:[],version:"current",frontMatter:{id:"plugin_intro",description:"Plugin introduction",slug:"/plugin/plugin_intro"},sidebar:"documentSidebar",previous:{title:"QWen",permalink:"/TaskWeaver/docs/llms/qwen"},next:{title:"Auto Plugin Selection",permalink:"/TaskWeaver/docs/customization/plugin/plugin_selection"}},l={},c=[{value:"Plugin Structure",id:"plugin-structure",level:2},{value:"Plugin Implementation",id:"plugin-implementation",level:2},{value:"Important Notes",id:"important-notes",level:3},{value:"Plugin Schema",id:"plugin-schema",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"plugin-introduction",children:"Plugin Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Plugins are the units that could be orchestrated by TaskWeaver. One could view the plugins as tools that the LLM can\r\nutilize to accomplish certain tasks."}),"\n",(0,i.jsx)(n.p,{children:"In TaskWeaver, each plugin is represented as a Python function that can be called within a code snippet. The\r\norchestration is essentially the process of generating Python code snippets consisting of a certain number of plugins.\r\nOne concrete example would be pulling data from database and apply anomaly detection. The generated code (simplified) looks like\r\nfollows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'df, data_description = sql_pull_data(query="pull data from time_series table")  \r\nanomaly_df, anomaly_description = anomaly_detection(df, time_col_name="ts", value_col_name="val") \n'})}),"\n",(0,i.jsx)(n.h2,{id:"plugin-structure",children:"Plugin Structure"}),"\n",(0,i.jsx)(n.p,{children:"A plugin has two files:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plugin Implementation"}),": a Python file that defines the plugin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plugin Schema"}),": a file in yaml that defines the schema of the plugin"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"plugin-implementation",children:"Plugin Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The plugin function needs to be implemented in Python.\r\nTo be coordinated with the orchestration by TaskWeaver, a plugin python file consists of two parts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Plugin function implementation code"}),"\n",(0,i.jsx)(n.li,{children:"TaskWeaver plugin decorator"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here we exhibit an example of the anomaly detection plugin as the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import pandas as pd\r\nfrom pandas.api.types import is_numeric_dtype\r\n\r\nfrom taskweaver.plugin import Plugin, register_plugin\r\n\r\n\r\n@register_plugin\r\nclass AnomalyDetectionPlugin(Plugin):\r\n    def __call__(self, df: pd.DataFrame, time_col_name: str, value_col_name: str):\r\n\r\n        """\r\n        anomaly_detection function identifies anomalies from an input dataframe of time series.\r\n        It will add a new column "Is_Anomaly", where each entry will be marked with "True" if the value is an anomaly\r\n        or "False" otherwise.\r\n\r\n        :param df: the input data, must be a dataframe\r\n        :param time_col_name: name of the column that contains the datetime\r\n        :param value_col_name: name of the column that contains the numeric values.\r\n        :return df: a new df that adds an additional "Is_Anomaly" column based on the input df.\r\n        :return description: the description about the anomaly detection results.\r\n        """\r\n        try:\r\n            df[time_col_name] = pd.to_datetime(df[time_col_name])\r\n        except Exception:\r\n            print("Time column is not datetime")\r\n            return\r\n\r\n        if not is_numeric_dtype(df[value_col_name]):\r\n            try:\r\n                df[value_col_name] = df[value_col_name].astype(float)\r\n            except ValueError:\r\n                print("Value column is not numeric")\r\n                return\r\n\r\n        mean, std = df[value_col_name].mean(), df[value_col_name].std()\r\n        cutoff = std * 3\r\n        lower, upper = mean - cutoff, mean + cutoff\r\n        df["Is_Anomaly"] = df[value_col_name].apply(lambda x: x < lower or x > upper)\r\n        anomaly_count = df["Is_Anomaly"].sum()\r\n        description = "There are {} anomalies in the time series data".format(anomaly_count)\r\n        \r\n        self.ctx.add_artifact(\r\n             name="anomaly_detection_results",  # a brief description of the artifact\r\n             file_name="anomaly_detection_results.csv",  # artifact file name\r\n             type="df",  # artifact data type, support chart/df/file/txt/svg\r\n             val=df,  # variable to be dumped\r\n        )\r\n        \r\n        return df, description\r\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"You need to go through the following steps to implement your own plugin."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["import the TaskWeaver plugin decorator ",(0,i.jsx)(n.code,{children:"from taskWeaver.plugin import Plugin, register_plugin"})]}),"\n",(0,i.jsxs)(n.li,{children:["create your plugin class inherited from ",(0,i.jsx)(n.code,{children:"Plugin"})," parent class (e.g., ",(0,i.jsx)(n.code,{children:"AnomalyDetectionPlugin(Plugin)"}),"), which is\r\ndecorated by ",(0,i.jsx)(n.code,{children:"@register_plugin"})]}),"\n",(0,i.jsxs)(n.li,{children:["implement your plugin function in ",(0,i.jsx)(n.code,{children:"__call__"})," method of the plugin class.  ",(0,i.jsxs)(n.strong,{children:["Most importantly, it is mandatory to\r\ninclude ",(0,i.jsx)(n.code,{children:"descriptions"})," of your execution results in the return values of your plugin function"]}),". These descriptions\r\ncan be utilized by the LLM to effectively summarize your execution results."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\ud83d\udca1A key difference in a plugin implementation and a normal python function is that it always return a description of\r\nthe result in natural language. As LLMs only understand natural language, it is important to let the model understand\r\nwhat the execution result is. In the example implementation above, the description says how many anomalies are detected.\r\nBehind the scene, only the description will be passed to the LLM model. In contrast, the execution result (e.g., df in\r\nthe above example) is not handled by the LLM."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the functionality of your plugin depends on additional libraries or packages, it is essential to ensure that they\r\nare installed before proceeding."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If you wish to persist intermediate results, such as data, figures, or prompts, in your plugin implementation,\r\nTaskWeaver provides an ",(0,i.jsx)(n.code,{children:"add_artifact"})," API that allows you to store these results in the workspace. In the example we\r\nprovide, if you have performed anomaly detection and obtained results in the form of a CSV file, you can utilize\r\nthe ",(0,i.jsx)(n.code,{children:"add_artifact"})," API to save this file as an artifact. The artifacts are stored in the ",(0,i.jsx)(n.code,{children:"project/workspace/session_id/cwd"})," folder in the project directory."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'self.ctx.add_artifact(\r\n    name="anomaly_detection_results",  # a brief description of the artifact\r\n    file_name="anomaly_detection_results.csv",  # artifact file name\r\n    type="df",  # artifact data type, support chart/df/file/txt/svg\r\n    val=df,  # variable to be dumped\r\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"plugin-schema",children:"Plugin Schema"}),"\n",(0,i.jsx)(n.p,{children:"The plugin schema is composed of several parts:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"}),": The main function name of the Python code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"enabled"}),": determine whether the plugin is enabled for selection during conversations. The default value is true."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"descriptions"}),": A brief description that introduces the plugin function."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"parameters"}),": This section lists all the input parameter information. It includes the parameter's name, type,\r\nwhether it is required or optional, and a description providing more details about the parameter."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"returns"}),": This section lists all the return value information. It includes the return value's name, type, and\r\ndescription that provides information about the value that is returned by the function."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," The addition of any extra fields would result in a validation failure within the plugin schema."]}),"\n",(0,i.jsx)(n.p,{children:"The plugin schema is required to be written in YAML format. Here is the plugin schema example of the above anomaly\r\ndetection plugin:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'name: anomaly_detection\r\nenabled: true\r\nrequired: false\r\ndescription: >-\r\n  anomaly_detection function identifies anomalies from an input DataFrame of\r\n  time series. It will add a new column "Is_Anomaly", where each entry will be marked with "True" if the value is an anomaly or "False" otherwise.\r\n\r\nparameters:\r\n  - name: df\r\n    type: DataFrame\r\n    required: true\r\n    description: >-\r\n      the input data from which we can identify the anomalies with the 3-sigma\r\n      algorithm.\r\n  - name: time_col_name\r\n    type: str\r\n    required: true\r\n    description: name of the column that contains the datetime\r\n  - name: value_col_name\r\n    type: str\r\n    required: true\r\n    description: name of the column that contains the numeric values.\r\n\r\nreturns:\r\n  - name: df\r\n    type: DataFrame\r\n    description: >-\r\n      This DataFrame extends the input DataFrame with a newly-added column\r\n      "Is_Anomaly" containing the anomaly detection result.\r\n  - name: description\r\n    type: str\r\n    description: This is a string describing the anomaly detection results.\r\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"Besides, we also set two optional fields as below:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"code"}),": Without specifying the code file name, the plugin schema will use the plugin name as the code file name.\r\nFor example, the plugin name is ",(0,i.jsx)(n.code,{children:"anomaly_detection"})," and the code file name is ",(0,i.jsx)(n.code,{children:"anomaly_detection.py"}),".\r\nIn cases where the plugin name is not the same as the code file name, you can specify the code name (code file) in\r\nthe plugin schema to ensure clarity and accuracy. For example, the plugin name is ",(0,i.jsx)(n.code,{children:"anomaly_detection"})," and the code\r\nfile name is ",(0,i.jsx)(n.code,{children:"anomaly_detection_code.py"}),". Then, you can specify the code name in the plugin schema as follows:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"code: anomaly_detection_code\n"})}),"\n","Note that the code file name should be the same as the code name without the ",(0,i.jsx)(n.code,{children:".py"})," extension."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"configurations"}),": When using common code that requires some configuration parameter modifications for different\r\nplugins, it is important to specify these configuration parameters in the plugin schema.\r\nThe configuration parameters are specified in the plugin schema as follows:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:" configurations:\r\n   key1: value1\r\n   key2: value2\n"})}),"\n","These configuration parameters can be accessed in the plugin implementation as follows:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'self.config.get("key1")\r\nself.config.get("key2")\n'})}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>o});var i=t(7294);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);